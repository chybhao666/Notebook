!想好怎么做，再写代码
!修改代码时注意前后相关的是否都已修改
!要提交的别忘了最后提交
! 参考别人做题情况，先易后难

我的头部：
#include <iostream>
using namespace std;
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <vector>
#include <map>
#include <set>
#define EACH(it,a) for(auto it=begin(a);it!=end(a);it++)
#define LL long long
#define INF 0x3f3f3f3f
const int SZ=1000;
int main()
{
    //ios_base::sync_with_stdio(0);
#ifdef LJY
    //freopen("in.txt","r",stdin);
#endif
    int i,j,k;

    return 0;
}

#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm> //没有c开头，也没有.h
#include <vector>
#include <string>
#include <map>
#include <set>
#include <cassert>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define foreach(it,a) for(typeof((a).begin()) it=(a).begin();it!=(a).end();it++) //vs10不支持typeof，可改为auto
#define all(x) (x).begin(),(x).end()
#define SZ(x) ((int)(x).size())
#define pb push_back
#define mp make_pair
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
template<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;} //这边的typename也可以换为class
#ifdef JCVB
#define debug(...) fprintf(stderr, __VA_ARGS__)
#else
#define debug(...) 
#endif
const ll mod=1000000007;
const int inf=0x3f3f3f3f;
const double pi    = acos(-1.0);
const double eps   = 1e-9;

#include<bits/stdc++.h>包含C++的所有头文件(部分oj支持)

cin，cout速度慢，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段ios_base::sync_with_stdio(false)可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几

########## 算法 ##########
##########################
《2013年王道论坛计算机考研机试指南》
最长递增子序列（LIS） dp(i)=max{1,dp[j]+1 | a[j]<a[i] && j<i}
最长公共子序列（LCS） ：
    若S1[x]==S2[y]，那么必存在一个最长公共子串以S1[x]或S2[y]结尾，其他部分等价于S1中前x-1个字符和S2中前y-1个字符的最长公共子串，即dp[x][y]=dp[x-1][y-1]+1。
    若S1[x]！=S2[y]，此时最长公共子串长度为S1中前x-1个字符和S2中前y个字符的最长公共子串长度和S1中前x个字符和S2中前y-1个字符的最长公共子串长度的较大者，即dp[x][y]=max{dp[x-1][y],dp[x][y-1]}。

LIS优化：简单的做法时间复杂度为n^2。保留满足dp[t] = k的所有a[t]中的最小值，即增加D[k] = min{a[t] | (dp[t] = k)} 。在D[]中查找时，可以使用二分查找高效地完成，则整个算法的时间复杂度下降为O(nlogn)。

最大回文串：
方法一、对每个位置向两边查看，对于较难的OJ可能会超时。（为方便奇数长和偶数长两种情况，需先填充）
方法二、与逆串求LCS，耗空间且时间复杂度高。（S=“abacdfgdcaba”, S′=“abacdgfdcaba”但LCS“abacd”并不是解，需处理）
方法三、Manacher算法，时间复杂度为O(n)。

《算法概论》
(完全背包问题) 多副本背包 K(w)  =max{K(w-w_i)+v_i}            最大价值dp[w]
(0-1背包问题)  单副本背包 K(w,j)=max{K(w-w_j,j-1),K(w,j-1)}           dp[w][j]
上面两个问题的时间复杂度其实一样。
在《王道》中，完全背包问题可以转为0-1背包问题，也就是让每件物品的数量为V/w_i，但当w_i较小时，时间复杂度太大。
(多重背包)     解决方法是转为0-1背包问题，但有个技巧，将某物品按数量：1,2,4，...，k-2^c+1 来分。
在空间上，背包问题需要一个二维数组存储。由于当前行数据只与上一行有关，所以可以优化为只使用两个一维数组。（比赛时没必要浪费时间去做这样的优化）

以上背包问题都是单个背包，不适用于多个背包问题。


在vs和G++中已有的:
xutility:min(),max()
utility: swap()

若果最大长度已知，使用数组也许比vector方便省时

调试时反复输入用例麻烦，可以使用freopen(const char *filename, const char *mode, FILE *stream); //其中stream为stdin/stdout

觉得代码没问题，结果却是Wrong Answer，原因可能是该用double或long long存储却用了int，也有可能是输出浮点数的格式问题。

abs(float)会有多个匹配问题。

交换两个等空间的数组时可以采用直接交换两个指针的方式。

觉得要用k重循环（即复杂度为n^k）时，应该采用递归，而不是去k个for循环。

自己想的解法有多次判断时，想想是否有其他方法减少判断次数。
例如：判断当前数在左半部分还是右半部分
      方法一：拿当前位置与中间位置比较，需要考虑总数为奇数偶数的情况，这样麻烦
      方法二：比较当前位置减去最小位置 和 最大位置减去当前位置 那个大

题目描述比较含糊，比如不知道数据范围是正整数还是自然数，这时看看输入部分的描述，也行会有启发。

有n堆水果已按单价从小到大排好，第i堆有m[i]个，每价c[i]，求买a个水果的最小花费
for(i=0;i<n && a>0;;i++){
    cost=min(a,m[i])*c[i]; //Good！
    a-=m[i];
}

while(cin>>a[i++]) ;  对于最后一次cin是什么也读不到的，但那次i自增了。把i++写在{}里比较好。

对于使用到链表的题目（如树），第一步就该是先判断proot是否为NULL

poj上C++代码若使用C语言的输入输出，需#include <stdio.h>

不要在栈上分配10^5以上空间，在全局区分配（若是运行时出错并提示栈错误，很可能就是栈上分配空间超过限制了）

使用memset时，需要#include<string.h> 不加的话在vs10下没问题，但G++会编译错误

自己实验发现‘在vs10中’对于int的输入，cin比scanf和输入外挂快，添加sync_with_stdio没影响

求中位数：
if (n & 0x1)
    return find(n/2 + 1);
else
    return ( find(n/2) + find(n/2 + 1) ) / 2; //当find()较为复杂时，这样写虽然耗时多了，但简化了代码，满足O(n)

